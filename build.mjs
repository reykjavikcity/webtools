// @ts-check
/* eslint-env es2022 */
import { execSync } from 'child_process';
import { readFileSync, writeFileSync } from 'fs';
import { readFile, writeFile } from 'fs/promises';
import globPkg from 'glob';

const glob = globPkg.sync;

// ---------------------------------------------------------------------------

const pkg = await readFile('./package.json').then((res) => JSON.parse(res.toString()));

const makePackageJson = (
  /** @type {string} */ outDir,
  /** @type {Record<string, unknown> | undefined} */ extraFields
) => {
  const libPkg = Object.fromEntries(
    Object.entries({
      ...pkg,
      ...pkg.dist_package_json,
      ...extraFields,
    }).filter(([_, value]) => value != null)
  );
  delete libPkg.dist_package_json;
  writeFileSync(outDir + '/package.json', JSON.stringify(libPkg, null, '\t'));
};

// ---------------------------------------------------------------------------

/** @typedef {{ compilerOptions: Record<string, unknown>; include: string[]; exlude?: string[] }}  TSConfig */
const tscBuild = (/** @type {TSConfig | undefined} */ config) => {
  const cfgFile = `tsconfig.build.TEMP.json`;
  writeFileSync(
    cfgFile,
    `// This file is auto-generated by build.mjs\n${JSON.stringify(
      { extends: './tsconfig.json', ...config },
      null,
      '\t'
    )}`
  );
  execSync(`yarn run tsc --project ${cfgFile}  &&  rm ${cfgFile}`);
};

// ---------------------------------------------------------------------------

const addReferenePathsToIndex = (
  /** @type {Array<string>} */ entryPoints,
  /** @type {string} */ distFolder
) => {
  const dtsify = (tsFilePath) => tsFilePath.replace(/\.(tsx?)$/, '.d.$1');
  const indexTsFile = entryPoints.find((filePath) => /^index.tsx?$/.test(filePath));

  if (indexTsFile) {
    const extraEntryPaths = entryPoints
      .filter((filePath) => filePath !== indexTsFile)
      .map(dtsify)
      .map((declFile) => `/// <reference path="./${declFile}" />`);
    if (extraEntryPaths.length > 0) {
      const indexDeclFile = `${distFolder}/${dtsify(indexTsFile)}`;
      const indexDecls =
        extraEntryPaths.join('\n') + `\n\n` + readFileSync(indexDeclFile);
      writeFileSync(indexDeclFile, indexDecls);
    }
  }
};

// ===========================================================================
// Build Library
// ===========================================================================

const srcDir = 'src';
const entryPoints = glob('**/*.{ts,tsx}', {
  cwd: srcDir,
  ignore: ['**/*.{tests,privates,d}.{ts,tsx}'],
});

const outDir = '_npm-dist';
const esmOutDir = `${outDir}/esm`;

// ---------------------------------------------------------------------------

execSync(
  [
    `rm -rf ${outDir}`,
    `mkdir ${outDir} ${outDir}/esm`,
    `cp README.md CHANGELOG.md ${outDir}`,
  ].join(' && ')
);
writeFile(`${outDir}/esm/package.json`, JSON.stringify({ type: 'module' }));

makePackageJson(outDir, {
  exports: entryPoints.reduce((exports, file) => {
    const token = file.replace(/\.ts$/, '');
    const expToken = token === 'index' ? '.' : `./${token}`;
    exports[expToken] = {
      import: `./esm/${token}.js`,
      require: `./${token}.js`,
    };
    return exports;
  }, {}),
});

const include = entryPoints.map((fileName) => `${srcDir}/${fileName}`);

tscBuild({ include, compilerOptions: { module: 'commonjs', outDir } });
addReferenePathsToIndex(entryPoints, outDir);

tscBuild({ include, compilerOptions: { module: 'esnext', outDir: esmOutDir } });
addReferenePathsToIndex(entryPoints, esmOutDir);
